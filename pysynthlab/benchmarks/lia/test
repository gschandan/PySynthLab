Problem:
(set-logic LIA)
(synth-fun f ((x Int) (y Int)) Int)
(declare-var x Int)
(declare-var y Int)
(constraint (= (f x y) (f y x)))
(constraint (and (<= x (f x y)) (<= y (f x y))))

verification file 1 (negated and conjoined the constraints):
(set-logic LIA)
(define-fun f ((x Int) (y Int)) Int x )
(declare-fun x () Int)
(declare-fun y ()Int)
(assert(or (not(= (f x y) (f y x))) (not (and (<= x (f x y)) (<= y (f x y))))))
(check-sat)
(get-model)

counter example:
cvc5 small.smt2 --produce-models
sat
(
(define-fun x () Int (- 1))
(define-fun y () Int 0)
)

Look for example that is sat when x = -1 and y = 0

synthesis guess 2:
(define-fun f ((x Int) (y Int)) Int 0 )

verification file 2:
(set-logic LIA)

(define-fun f ((x Int) (y Int)) Int 0 )

(declare-fun x () Int)
(declare-fun y ()Int)
(assert(or (not(= (f x y) (f y x)))
        (not (and (<= x (f x y))
             (<= y (f x y))))))

(check-sat)
(get-model)

counter example:
counterexaple 2: sat
(
(define-fun x () Int 1)
(define-fun y () Int 0)
)

synthesis guess 3:
(set-logic LIA)

(define-fun f ((x Int) (y Int)) Int (ite (<= x y) y x))

(declare-fun x () Int)
(declare-fun y ()Int)
(assert(or (not(= (f x y) (f y x)))
(not (and (<= x (f x y)) (<= y (f x y))))))
(check-sat)
(get-model)
No counterexample -> end as we have a valid candidate program

counterexamples - check candidate just for counterexamples rather than running against whole verifier
continue enumerating until something works for counterexamples
(set-logic LIA)

(define-fun f ((x Int) (y Int)) Int (ite (<= x y) y x))

(declare-fun x () Int)
(declare-fun y ()Int)
(assert(or (not(= (f x y) (f y x)))
(not (and (<= x (f x y)) (<= y (f x y))))))
(check-sat)
(get-model)

Need to disjunction assertion one and 2
new query - against same constraints - only needs to work when x = 0 and y =1
or with another counter example

(assert(or (not(= (f x y) (f y x)))
(not (and (<= x (f x y)) (<= y (f x y))))))

counterexamples - check problem just for counterexamples rather than running against whole verifier
separate verifier

basic cegis -> writeup
literature -> how to modify the code to implement variations and documentation and comparisons
i.e. as a researcher how to implement


(set-logic LIA)

(define-fun f ((x Int) (y Int)) Int (ite (<= x y) y x))

(declare-fun x () Int)
(declare-fun y ()Int)
(assert(or (not(= (f x y) (f y x)))
        (not (and (<= x (f x y))
             (<= y (f x y))))))
(check-sat)
(get-model)

def add_negated_constraints(solver, f_guess):
    x, y = Ints('x y')
    f_x_y = f_guess(x, y)
    f_y_x = f_guess(y, x)
    solver.add(Or(Not(f_x_y == f_y_x), Not(And(x <= f_x_y, y <= f_x_y))))


def add_original_constraints(solver, f_guess):
    x, y = Ints('x y')
    f_x_y = f_guess(x, y)
    f_y_x = f_guess(y, x)
    solver.add(And((f_x_y == f_y_x), And(x <= f_x_y, y <= f_x_y)))


guesses = [
    (lambda a, b: 0, "f(x, y) = 0"),
    (lambda a, b: a, "f(x, y) = x"),
    (lambda a, b: b, "f(x, y) = y"),
    (lambda a, b: a - b, "f(x, y) = x - y"),
    (lambda a, b: If(a <= b, b, a), "f(x, y) = max(x, y)"),
]

print("METOD 2: python function substitution")

    def add_negated_constraints(solver, f_guess):
        x, y = Ints('x y')
        f_x_y = f_guess(x, y)
        f_y_x = f_guess(y, x)
        solver.add(Or(Not(f_x_y == f_y_x), Not(And(x <= f_x_y, y <= f_x_y))))

    def add_original_constraints(solver, f_guess):
        x, y = Ints('x y')
        f_x_y = f_guess(x, y)
        f_y_x = f_guess(y, x)
        solver.add(And((f_x_y == f_y_x), And(x <= f_x_y, y <= f_x_y)))

    guesses = [
        (lambda a, b: 0, "f(x, y) = 0"),
        (lambda a, b: a, "f(x, y) = x"),
        (lambda a, b: b, "f(x, y) = y"),
        (lambda a, b: a - b, "f(x, y) = x - y"),
        (lambda a, b: If(a <= b, b, a), "f(x, y) = max(x, y)"),
    ]

    for guess, name in guesses:
        enumerator = Solver()
        add_negated_constraints(enumerator, guess)
        print("ENUMAERATOR:", enumerator.to_smt2())

        if enumerator.check() == sat:
            model = enumerator.model()
            print(
                f"Counterexample for guess {name}: x = {model.evaluate(Int('x'))}, y = {model.evaluate(Int('y'))}")

            verifier = Solver()
            add_original_constraints(verifier, guess)
            verifier.add(Int('x') == model[Int('x')], Int('y') == model[Int('y')])
            print("VERIFIER:", verifier.to_smt2())

            if verifier.check() == sat:
                print(f"Verification passed unexpectedly for guess {name}. Possible error in logic.")
            else:
                print(f"Verification failed for guess {name}, counterexample confirmed.")
        else:
            verifier = Solver()
            add_original_constraints(verifier, guess)
            print("VERIFIER:", verifier.to_smt2())
            if verifier.check() == sat:
                print(f"No counterexample found for guess {name}. Guess should be correct.")
            else:
                print(f"Verification failed unexpectedly for guess {name}. Possible error in logic.")
        print("-" * 50)

 print("METHOD 1: string maniuplation")
    base_problem = """
        (declare-fun f (Int Int) Int)
        (declare-fun x () Int)
        (declare-fun y () Int)
        (assert(or (not(= (f x y) (f y x))) (not (and (<= x (f x y)) (<= y (f x y))))))
        """

    guesses = [
        "(define-fun f ((x Int) (y Int)) Int x)",  # Guess 1: f(x, y) = x
        "(define-fun f ((x Int) (y Int)) Int y)",  # Guess 2: f(x, y) = y
        "(define-fun f ((x Int) (y Int)) Int (ite (<= x y) x y))",  # Guess 3: f(x, y) = min(x, y)
        "(define-fun f ((x Int) (y Int)) Int (ite (<= x y) y x))",  # Guess 4: f(x, y) = max(x, y)
    ]

    def try_guess(base_problem, guess):
        smt_lib_str = guess + base_problem + "(check-sat)(get-model)"
        solver = z3.Solver()
        solver.from_string(smt_lib_str)
        print("SMT:", solver.to_smt2())
        if solver.check() == z3.sat:
            print(f"Guess '{guess}' is not valid, found counterexample:")
            print(solver.model())
            return False
        else:
            print(f"Guess '{guess}' is potentially correct, no counterexample found.")
            return True

    for guess in guesses:
        if try_guess(base_problem, guess):
            break

print("CVC5")

    def create_solver_with_vars():
        solver = cvc5.Solver()
        solver.setOption("produce-models", "true")
        x = solver.mkConst(solver.getIntegerSort(), "x")
        y = solver.mkConst(solver.getIntegerSort(), "y")
        return solver, x, y

    def add_negated_constraints(solver, x, y, f_guess):
        f_x_y = f_guess(x, y)
        f_y_x = f_guess(y, x)
        not_equal = solver.mkTerm(cvc5.Kind.NOT, solver.mkTerm(cvc5.Kind.EQUAL, f_x_y, f_y_x))
        not_monotonic = solver.mkTerm(cvc5.Kind.NOT,
                                      solver.mkTerm(cvc5.Kind.AND, solver.mkTerm(cvc5.Kind.LEQ, x, f_x_y),
                                                    solver.mkTerm(cvc5.Kind.LEQ, y, f_x_y)))
        solver.assertFormula(solver.mkTerm(cvc5.Kind.OR, not_equal, not_monotonic))

    guesses = [
        (lambda a, b: solver.mkInteger(0), "f(x, y) = 0"),
        (lambda a, b: a, "f(x, y) = x"),
        (lambda a, b: b, "f(x, y) = y"),
        (lambda a, b: solver.mkTerm(cvc5.Kind.SUB, a, b), "f(x, y) = x - y"),
        (
        lambda a, b: solver.mkTerm(cvc5.Kind.ITE, solver.mkTerm(cvc5.Kind.LEQ, a, b), b, a), "f(x, y) = max(x, y)"),
    ]

    for guess_func, name in guesses:
        solver, x, y = create_solver_with_vars()
        add_negated_constraints(solver, x, y, guess_func)

        result = solver.checkSat()
        if result.isSat():
            model = solver.getModel([], [x, y])
            print(f"Model for guess {name}: x = {model[0]}, y = {model[1]}")
        else:
            print(f"No model for guess {name}.")

        print("-" * 50)